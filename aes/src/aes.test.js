/**
 * Test cases from Appendix B
 */

const { subBytes, shiftRows, mixColumns, addRoundKey, expandKey } = require('./aes');

test('subBytes', () => {
  let state = [
    [0x19, 0xa0, 0x9a, 0xe9],
    [0x3d, 0xf4, 0xc6, 0xf8],
    [0xe3, 0xe2, 0x8d, 0x48],
    [0xbe, 0x2b, 0x2a, 0x08],
  ];

  subBytes(state);

  expect(state).toEqual([
    [0xd4, 0xe0, 0xb8, 0x1e],
    [0x27, 0xbf, 0xb4, 0x41],
    [0x11, 0x98, 0x5d, 0x52],
    [0xae, 0xf1, 0xe5, 0x30],
  ]);
});

test('shiftRows', () => {
  let state = [
    [0xd4, 0xe0, 0xb8, 0x1e],
    [0x27, 0xbf, 0xb4, 0x41],
    [0x11, 0x98, 0x5d, 0x52],
    [0xae, 0xf1, 0xe5, 0x30],
  ];

  shiftRows(state);

  expect(state).toEqual([
    [0xd4, 0xe0, 0xb8, 0x1e],
    [0xbf, 0xb4, 0x41, 0x27],
    [0x5d, 0x52, 0x11, 0x98],
    [0x30, 0xae, 0xf1, 0xe5],
  ]);
});

test('mixColumns', () => {
  let state = [
    [0xd4, 0xe0, 0xb8, 0x1e],
    [0xbf, 0xb4, 0x41, 0x27],
    [0x5d, 0x52, 0x11, 0x98],
    [0x30, 0xae, 0xf1, 0xe5],
  ];

  mixColumns(state);

  expect(state).toEqual([
    [0x04, 0xe0, 0x48, 0x28],
    [0x66, 0xcb, 0xf8, 0x06],
    [0x81, 0x19, 0xd3, 0x26],
    [0xe5, 0x9a, 0x7a, 0x4c],
  ]);
});

test('addRoundKey', () => {
  let state = [
    [0x04, 0xe0, 0x48, 0x28],
    [0x66, 0xcb, 0xf8, 0x06],
    [0x81, 0x19, 0xd3, 0x26],
    [0xe5, 0x9a, 0x7a, 0x4c],
  ];
  let key = [
    [0xa0, 0x88, 0x23, 0x2a],
    [0xfa, 0x54, 0xa3, 0x6c],
    [0xfe, 0x2c, 0x39, 0x76],
    [0x17, 0xb1, 0x39, 0x05],
  ];

  addRoundKey(state, key);

  expect(state).toEqual([
    [0xa4, 0x68, 0x6b, 0x02],
    [0x9c, 0x9f, 0x5b, 0x6a],
    [0x7f, 0x35, 0xea, 0x50],
    [0xf2, 0x2b, 0x43, 0x49],
  ]);
});

test('expandKey', () => {
  let key = [
    [0x2b, 0x7e, 0x15, 0x16],
    [0x28, 0xae, 0xd2, 0xa6],
    [0xab, 0xf7, 0x15, 0x88],
    [0x09, 0xcf, 0x4f, 0x3c],
  ];

  let roundKeys = expandKey(key);

  expect(roundKeys.length).toBe(44);
  expect(roundKeys.slice(-1)).toEqual([
    [0xb6, 0x63, 0x0c, 0xa6],
  ]);
});
