/**
 * Test cases from Appendix B
 */

const { subBytes, shiftRows, mixColumns, addRoundKey, expandKey, cipher, invCipher } = require('./aes');

function fromHex(hex) {
  return [...hex.matchAll(/[\da-f]{2} ?/g)].map(byte => parseInt(byte, 16));
}

test('subBytes', () => {
  let state = [
    [0x19, 0xa0, 0x9a, 0xe9],
    [0x3d, 0xf4, 0xc6, 0xf8],
    [0xe3, 0xe2, 0x8d, 0x48],
    [0xbe, 0x2b, 0x2a, 0x08],
  ];

  subBytes(state);

  expect(state).toEqual([
    [0xd4, 0xe0, 0xb8, 0x1e],
    [0x27, 0xbf, 0xb4, 0x41],
    [0x11, 0x98, 0x5d, 0x52],
    [0xae, 0xf1, 0xe5, 0x30],
  ]);
});

test('shiftRows', () => {
  let state = [
    [0xd4, 0xe0, 0xb8, 0x1e],
    [0x27, 0xbf, 0xb4, 0x41],
    [0x11, 0x98, 0x5d, 0x52],
    [0xae, 0xf1, 0xe5, 0x30],
  ];

  shiftRows(state);

  expect(state).toEqual([
    [0xd4, 0xe0, 0xb8, 0x1e],
    [0xbf, 0xb4, 0x41, 0x27],
    [0x5d, 0x52, 0x11, 0x98],
    [0x30, 0xae, 0xf1, 0xe5],
  ]);
});

test('mixColumns', () => {
  let state = [
    [0xd4, 0xe0, 0xb8, 0x1e],
    [0xbf, 0xb4, 0x41, 0x27],
    [0x5d, 0x52, 0x11, 0x98],
    [0x30, 0xae, 0xf1, 0xe5],
  ];

  mixColumns(state);

  expect(state).toEqual([
    [0x04, 0xe0, 0x48, 0x28],
    [0x66, 0xcb, 0xf8, 0x06],
    [0x81, 0x19, 0xd3, 0x26],
    [0xe5, 0x9a, 0x7a, 0x4c],
  ]);
});

test('addRoundKey', () => {
  let state = [
    [0x04, 0xe0, 0x48, 0x28],
    [0x66, 0xcb, 0xf8, 0x06],
    [0x81, 0x19, 0xd3, 0x26],
    [0xe5, 0x9a, 0x7a, 0x4c],
  ];
  let key = [
    [0xa0, 0xfa, 0xfe, 0x17],
    [0x88, 0x54, 0x2c, 0xb1],
    [0x23, 0xa3, 0x39, 0x39],
    [0x2a, 0x6c, 0x76, 0x05],
  ];

  addRoundKey(state, key);

  expect(state).toEqual([
    [0xa4, 0x68, 0x6b, 0x02],
    [0x9c, 0x9f, 0x5b, 0x6a],
    [0x7f, 0x35, 0xea, 0x50],
    [0xf2, 0x2b, 0x43, 0x49],
  ]);
});

test('expandKey', () => {
  let key = fromHex('2b 7e 15 16 28 ae d2 a6 ab f7 15 88 09 cf 4f 3c');

  let roundKeys = expandKey(key);

  expect(roundKeys.length).toBe(44);
  expect(roundKeys.slice(-1)).toEqual([
    [0xb6, 0x63, 0x0c, 0xa6],
  ]);
});

test('cipher', () => {
  let input = fromHex('32 43 f6 a8 88 5a 30 8d 31 31 98 a2 e0 37 07 34');
  let key = fromHex('2b 7e 15 16 28 ae d2 a6 ab f7 15 88 09 cf 4f 3c');
  let keySchedule = expandKey(key);

  let cipherText = cipher(input, keySchedule);

  expect(cipherText).toEqual(fromHex('39 25 84 1d 02 dc 09 fb dc 11 85 97 19 6a 0b 32'));
});

test('invCipher', () => {
  let input = fromHex('39 25 84 1d 02 dc 09 fb dc 11 85 97 19 6a 0b 32');
  let key = fromHex('2b 7e 15 16 28 ae d2 a6 ab f7 15 88 09 cf 4f 3c');
  let keySchedule = expandKey(key);

  let plaintext = invCipher(input, keySchedule);

  expect(plaintext).toEqual(fromHex('32 43 f6 a8 88 5a 30 8d 31 31 98 a2 e0 37 07 34'));
});
