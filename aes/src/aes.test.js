/**
 * Test cases from Appendix B
 */

const { subBytes, shiftRows, mixColumns, addRoundKey, expandKey, cipher, invCipher } = require('./aes');

function fromHex(hex) {
  return [...hex.matchAll(/[\da-f]{2} ?/g)].map(byte => parseInt(byte, 16));
}

test('subBytes', () => {
  let state = [
    [0x19, 0xa0, 0x9a, 0xe9],
    [0x3d, 0xf4, 0xc6, 0xf8],
    [0xe3, 0xe2, 0x8d, 0x48],
    [0xbe, 0x2b, 0x2a, 0x08],
  ];

  subBytes(state);

  expect(state).toEqual([
    [0xd4, 0xe0, 0xb8, 0x1e],
    [0x27, 0xbf, 0xb4, 0x41],
    [0x11, 0x98, 0x5d, 0x52],
    [0xae, 0xf1, 0xe5, 0x30],
  ]);
});

test('shiftRows', () => {
  let state = [
    [0xd4, 0xe0, 0xb8, 0x1e],
    [0x27, 0xbf, 0xb4, 0x41],
    [0x11, 0x98, 0x5d, 0x52],
    [0xae, 0xf1, 0xe5, 0x30],
  ];

  shiftRows(state);

  expect(state).toEqual([
    [0xd4, 0xe0, 0xb8, 0x1e],
    [0xbf, 0xb4, 0x41, 0x27],
    [0x5d, 0x52, 0x11, 0x98],
    [0x30, 0xae, 0xf1, 0xe5],
  ]);
});

test('mixColumns', () => {
  let state = [
    [0xd4, 0xe0, 0xb8, 0x1e],
    [0xbf, 0xb4, 0x41, 0x27],
    [0x5d, 0x52, 0x11, 0x98],
    [0x30, 0xae, 0xf1, 0xe5],
  ];

  mixColumns(state);

  expect(state).toEqual([
    [0x04, 0xe0, 0x48, 0x28],
    [0x66, 0xcb, 0xf8, 0x06],
    [0x81, 0x19, 0xd3, 0x26],
    [0xe5, 0x9a, 0x7a, 0x4c],
  ]);
});

test('addRoundKey', () => {
  let state = [
    [0x04, 0xe0, 0x48, 0x28],
    [0x66, 0xcb, 0xf8, 0x06],
    [0x81, 0x19, 0xd3, 0x26],
    [0xe5, 0x9a, 0x7a, 0x4c],
  ];
  let key = [
    [0xa0, 0x88, 0x23, 0x2a],
    [0xfa, 0x54, 0xa3, 0x6c],
    [0xfe, 0x2c, 0x39, 0x76],
    [0x17, 0xb1, 0x39, 0x05],
  ];

  addRoundKey(state, key);

  expect(state).toEqual([
    [0xa4, 0x68, 0x6b, 0x02],
    [0x9c, 0x9f, 0x5b, 0x6a],
    [0x7f, 0x35, 0xea, 0x50],
    [0xf2, 0x2b, 0x43, 0x49],
  ]);
});

test('expandKey', () => {
  let key = fromHex("2b7e151628aed2a6abf7158809cf4f3c");

  let roundKeys = expandKey(key);

  expect(roundKeys.length).toBe(44);
  expect(roundKeys.slice(-1)).toEqual([
    [0xb6, 0x63, 0x0c, 0xa6],
  ]);
});

test('cipher #1', () => {
  let input = fromHex("32 43 f6 a8 88 5a 30 8d 31 31 98 a2 e0 37 07 34")
  let key = fromHex("2b 7e 15 16 28 ae d2 a6 ab f7 15 88 09 cf 4f 3c");
  let keySchedule = expandKey(key);

  let cipherText = cipher(input, keySchedule);

  expect(cipherText).toEqual([
    [0x39, 0x02, 0xdc, 0x19],
    [0x25, 0xdc, 0x11, 0x6a],
    [0x84, 0x09, 0x85, 0x0b],
    [0x1d, 0xfb, 0x97, 0x32],
  ]);
})

test('cipher #2', () => {
  let input = "00112233445566778899aabbccddeeff";
  let key = "000102030405060708090a0b0c0d0e0f";
  let keySchedule = expandKey(key);

  let cipherText = cipher(input, keySchedule);

  expect(cipherText).toEqual([
    [0x39, 0x02, 0xdc, 0x19],
    [0x25, 0xdc, 0x11, 0x6a],
    [0x84, 0x09, 0x85, 0x0b],
    [0x1d, 0xfb, 0x97, 0x32],
  ]);
});

test('invCipher', () => {
  let input = new Uint8Array([
    0x69, 0xc4, 0xe0, 0xd8, 0x6a, 0x7b, 0x04, 0x30, 0xd8, 0xcd, 0xb7, 0x80, 0x70, 0xb4, 0xc5, 0x5a,
  ]);
  let key = [
    [0x00, 0x01, 0x02, 0x03],
    [0x04, 0x05, 0x06, 0x07],
    [0x08, 0x09, 0x0a, 0x0b],
    [0x0c, 0x0d, 0x0e, 0x0f],
  ];
  let keySchedule = expandKey(key);

  let plaintext = invCipher(input, keySchedule);

  expect(plaintext).toEqual([
    0x32, 0x43, 0xf6, 0xa8, 0x88, 0x5a, 0x30, 0x8d, 0x31, 0x31, 0x98, 0xa2, 0xe0, 0x37, 0x07, 0x34,
  ]);
});
