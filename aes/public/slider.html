<!doctype html>
<html lang='en'>
<head>
  <meta charset='UTF-8'>
  <title>AES 128 step by step</title>
  <style>
      #plots {
          display: flex;
          gap: 1rem;
      }

      label {
          width: 100px;
          display: inline-block;
          line-height: 150%;
          margin-top: 0.25rem;
      }

      * {
          font-family: monospace;
      }

      .faded {
          color: gray;
      }

      .current {
          font-weight: bold;
      }

      #viz {
          display: flex;
          gap: 1rem;
          align-items: start;
          margin-top: 2rem;
      }

      #bitmap {
          border: 2px solid black;
          grid-row: span 2;
          display: grid;
          gap: 2px;
          grid-template-columns: repeat(8, 3rem);
          grid-template-rows: repeat(16, 3rem);
          background-color: black;
      }

      #plot {
          border: 2px solid black;
          display: grid;
          gap: 2px;
          grid-template-columns: repeat(16, 2rem);
          grid-template-rows: repeat(1, 100%);
          align-items: end;
          justify-self: stretch;
          background-color: black;
      }

      #plot span {
          background-color: yellowgreen;
      }

      #controls {
          display: flex;
          gap: 1rem;
      }
  </style>
</head>
<body>
<h1>AES 128</h1>
<div>
  <label>Plaintext:<input id='plaintext' value='00 00 00 00 00 00 00 ff ff 00 00 00 00 00 00 00' size='47'></label>
</div>
<div>
  <label>Key: <input id='keyInput' value='00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00' size='47'></label>
</div>
<div>
  <label>Ciphertext: <input id='cipherText' value='???' disabled size='47'></label>
</div>
<div id='viz'>
  <ol id='steps'></ol>
  <div id='plots'>
    <div id='bitmap'></div>
    <div id='plot'></div>
  </div>
</div>
<input id='slider' type='range' min='0' max='42' value='0'>
</body>
<script>
  const numColumns = 4;
  const Nr = 4;
  const numRounds = 10;

  // XORShift after multiplicative inverse, see ยง5.1.1
  const S_BOX = [0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16];

  // (Polynomial multiplication tables from https://en.wikipedia.org/wiki/Rijndael_MixColumns)
  let MUL = [
    [0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff],
    [0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e, 0x10, 0x12, 0x14, 0x16, 0x18, 0x1a, 0x1c, 0x1e, 0x20, 0x22, 0x24, 0x26, 0x28, 0x2a, 0x2c, 0x2e, 0x30, 0x32, 0x34, 0x36, 0x38, 0x3a, 0x3c, 0x3e, 0x40, 0x42, 0x44, 0x46, 0x48, 0x4a, 0x4c, 0x4e, 0x50, 0x52, 0x54, 0x56, 0x58, 0x5a, 0x5c, 0x5e, 0x60, 0x62, 0x64, 0x66, 0x68, 0x6a, 0x6c, 0x6e, 0x70, 0x72, 0x74, 0x76, 0x78, 0x7a, 0x7c, 0x7e, 0x80, 0x82, 0x84, 0x86, 0x88, 0x8a, 0x8c, 0x8e, 0x90, 0x92, 0x94, 0x96, 0x98, 0x9a, 0x9c, 0x9e, 0xa0, 0xa2, 0xa4, 0xa6, 0xa8, 0xaa, 0xac, 0xae, 0xb0, 0xb2, 0xb4, 0xb6, 0xb8, 0xba, 0xbc, 0xbe, 0xc0, 0xc2, 0xc4, 0xc6, 0xc8, 0xca, 0xcc, 0xce, 0xd0, 0xd2, 0xd4, 0xd6, 0xd8, 0xda, 0xdc, 0xde, 0xe0, 0xe2, 0xe4, 0xe6, 0xe8, 0xea, 0xec, 0xee, 0xf0, 0xf2, 0xf4, 0xf6, 0xf8, 0xfa, 0xfc, 0xfe, 0x1b, 0x19, 0x1f, 0x1d, 0x13, 0x11, 0x17, 0x15, 0x0b, 0x09, 0x0f, 0x0d, 0x03, 0x01, 0x07, 0x05, 0x3b, 0x39, 0x3f, 0x3d, 0x33, 0x31, 0x37, 0x35, 0x2b, 0x29, 0x2f, 0x2d, 0x23, 0x21, 0x27, 0x25, 0x5b, 0x59, 0x5f, 0x5d, 0x53, 0x51, 0x57, 0x55, 0x4b, 0x49, 0x4f, 0x4d, 0x43, 0x41, 0x47, 0x45, 0x7b, 0x79, 0x7f, 0x7d, 0x73, 0x71, 0x77, 0x75, 0x6b, 0x69, 0x6f, 0x6d, 0x63, 0x61, 0x67, 0x65, 0x9b, 0x99, 0x9f, 0x9d, 0x93, 0x91, 0x97, 0x95, 0x8b, 0x89, 0x8f, 0x8d, 0x83, 0x81, 0x87, 0x85, 0xbb, 0xb9, 0xbf, 0xbd, 0xb3, 0xb1, 0xb7, 0xb5, 0xab, 0xa9, 0xaf, 0xad, 0xa3, 0xa1, 0xa7, 0xa5, 0xdb, 0xd9, 0xdf, 0xdd, 0xd3, 0xd1, 0xd7, 0xd5, 0xcb, 0xc9, 0xcf, 0xcd, 0xc3, 0xc1, 0xc7, 0xc5, 0xfb, 0xf9, 0xff, 0xfd, 0xf3, 0xf1, 0xf7, 0xf5, 0xeb, 0xe9, 0xef, 0xed, 0xe3, 0xe1, 0xe7, 0xe5],
    [0x00, 0x03, 0x06, 0x05, 0x0c, 0x0f, 0x0a, 0x09, 0x18, 0x1b, 0x1e, 0x1d, 0x14, 0x17, 0x12, 0x11, 0x30, 0x33, 0x36, 0x35, 0x3c, 0x3f, 0x3a, 0x39, 0x28, 0x2b, 0x2e, 0x2d, 0x24, 0x27, 0x22, 0x21, 0x60, 0x63, 0x66, 0x65, 0x6c, 0x6f, 0x6a, 0x69, 0x78, 0x7b, 0x7e, 0x7d, 0x74, 0x77, 0x72, 0x71, 0x50, 0x53, 0x56, 0x55, 0x5c, 0x5f, 0x5a, 0x59, 0x48, 0x4b, 0x4e, 0x4d, 0x44, 0x47, 0x42, 0x41, 0xc0, 0xc3, 0xc6, 0xc5, 0xcc, 0xcf, 0xca, 0xc9, 0xd8, 0xdb, 0xde, 0xdd, 0xd4, 0xd7, 0xd2, 0xd1, 0xf0, 0xf3, 0xf6, 0xf5, 0xfc, 0xff, 0xfa, 0xf9, 0xe8, 0xeb, 0xee, 0xed, 0xe4, 0xe7, 0xe2, 0xe1, 0xa0, 0xa3, 0xa6, 0xa5, 0xac, 0xaf, 0xaa, 0xa9, 0xb8, 0xbb, 0xbe, 0xbd, 0xb4, 0xb7, 0xb2, 0xb1, 0x90, 0x93, 0x96, 0x95, 0x9c, 0x9f, 0x9a, 0x99, 0x88, 0x8b, 0x8e, 0x8d, 0x84, 0x87, 0x82, 0x81, 0x9b, 0x98, 0x9d, 0x9e, 0x97, 0x94, 0x91, 0x92, 0x83, 0x80, 0x85, 0x86, 0x8f, 0x8c, 0x89, 0x8a, 0xab, 0xa8, 0xad, 0xae, 0xa7, 0xa4, 0xa1, 0xa2, 0xb3, 0xb0, 0xb5, 0xb6, 0xbf, 0xbc, 0xb9, 0xba, 0xfb, 0xf8, 0xfd, 0xfe, 0xf7, 0xf4, 0xf1, 0xf2, 0xe3, 0xe0, 0xe5, 0xe6, 0xef, 0xec, 0xe9, 0xea, 0xcb, 0xc8, 0xcd, 0xce, 0xc7, 0xc4, 0xc1, 0xc2, 0xd3, 0xd0, 0xd5, 0xd6, 0xdf, 0xdc, 0xd9, 0xda, 0x5b, 0x58, 0x5d, 0x5e, 0x57, 0x54, 0x51, 0x52, 0x43, 0x40, 0x45, 0x46, 0x4f, 0x4c, 0x49, 0x4a, 0x6b, 0x68, 0x6d, 0x6e, 0x67, 0x64, 0x61, 0x62, 0x73, 0x70, 0x75, 0x76, 0x7f, 0x7c, 0x79, 0x7a, 0x3b, 0x38, 0x3d, 0x3e, 0x37, 0x34, 0x31, 0x32, 0x23, 0x20, 0x25, 0x26, 0x2f, 0x2c, 0x29, 0x2a, 0x0b, 0x08, 0x0d, 0x0e, 0x07, 0x04, 0x01, 0x02, 0x13, 0x10, 0x15, 0x16, 0x1f, 0x1c, 0x19, 0x1a],
  ];

  // Powers of polynomial x in GF2**8, see ยง4.2 and ยง5.2
  const ROUND_CONSTANTS = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];

  // Various helpers and building blocks
  let subWord = (word, mapping = S_BOX) => word.forEach((e, i) => word[i] = mapping[e]);
  let subBytes = (state, mapping = S_BOX) => state.forEach(row => subWord(row, mapping));
  let shiftRows = state => state.forEach(rotWord);
  let rotWord = (temp, n = 1) => temp.push(...(temp.splice(0, n)));
  let xorRow = (row, key) => row.forEach((_, i) => row[i] ^= key[i]);
  let xorArray = (array, key) => array.forEach((row, i) => xorRow(row, key[i]));
  let makeRoundKey = (w, round) => w.slice(round * numColumns, (round + 1) * (numColumns));
  let addRoundKey = (state, key) => xorArray(state, transpose(key));
  let transpose = array => array[0].map((_, column) => array.map(row => row[column]));
  let chunks = key => [key.slice(0, 4), key.slice(4, 8), key.slice(8, 12), key.slice(12, 16)];
  let fromHex = hex => [...hex.matchAll(/[\da-f]{2} ?/g)].map(byte => parseInt(byte, 16));
  let toHex = xs => xs.map(x => x.toString(16).padStart(2, '0')).join(' ');
  let storeState = (description, state) => states.push({ description, state: JSON.parse(JSON.stringify(state)) });

  // Polynomial multiplication modulo x^4 + 1, see ยง5.1.3
  function mixColumns(state, coefficients = [2, 1, 1, 3]) {
    for (let col = 0; col < numColumns; col++) {
      let [a, b, c, d] = [state[0][col], state[1][col], state[2][col], state[3][col]];
      let [i, j, k, l] = coefficients;
      state[0][col] = MUL[i - 1][a] ^ MUL[l - 1][b] ^ MUL[k - 1][c] ^ MUL[j - 1][d];
      state[1][col] = MUL[j - 1][a] ^ MUL[i - 1][b] ^ MUL[l - 1][c] ^ MUL[k - 1][d];
      state[2][col] = MUL[k - 1][a] ^ MUL[j - 1][b] ^ MUL[i - 1][c] ^ MUL[l - 1][d];
      state[3][col] = MUL[l - 1][a] ^ MUL[k - 1][b] ^ MUL[j - 1][c] ^ MUL[i - 1][d];
    }
  }

  function expandKey(key) {
    let words = chunks(key);
    for (let i = Nr; i < numColumns * (numRounds + 1); i++) {
      let temp = [...words[i - 1]];
      if (i % Nr === 0) {
        rotWord(temp);
        subWord(temp);
        temp[0] ^= ROUND_CONSTANTS[Math.floor(i / Nr)];
      }
      words[i] = [...words[i - Nr]];
      xorRow(words[i], temp);
    }
    return words;
  }


  function cipher(input, w) {
    states = [];
    let initial = chunks(input);
    storeState('initial', initial);
    let state = transpose(initial);
    storeState('transpose', state);
    addRoundKey(state, makeRoundKey(w, 0));
    storeState('add round key', state);

    for (let round = 1; round < numRounds; round++) {
      subBytes(state);
      storeState('substitute bytes', state);
      shiftRows(state);
      storeState('shift rows', state);
      mixColumns(state);
      storeState('mix columns', state);
      addRoundKey(state, makeRoundKey(w, round));
      storeState('add round key', state);
    }

    subBytes(state);
    storeState('substitute bytes', state);
    shiftRows(state);
    storeState('shift rows', state);
    addRoundKey(state, makeRoundKey(w, numRounds));
    storeState('add round key', state);

    state = transpose(state);
    storeState('transpose', state);
    return state.flatMap(x => x);
  }

  function generateSteps() {
    let addStep = text => {
      let item = document.createElement('li');
      item.innerText = text;
      steps.appendChild(item);
    };

    addStep('input');
    addStep('transposed');
    addStep('add round key');
    for (let step = 0; step < 9; step++) {
      addStep('substitute bytes');
      addStep('shift rows');
      addStep('mix columns');
      addStep('add round key');
    }
    addStep('substitute bytes');
    addStep('shift rows');
    addStep('add round key');
    addStep('result');
  }

  function generateBitmap() {
    for (let bit = 0; bit < 128; bit++) {
      let bitDiv = document.createElement('span');
      bitDiv.setAttribute('id', `bit_${bit}`);
      bitmap.appendChild(bitDiv);
    }
  }

  function generateBars() {
    for (let bit = 0; bit < 16; bit++) {
      let byteDiv = document.createElement('span');
      byteDiv.setAttribute('id', `bar_${bit}`);
      plot.appendChild(byteDiv);
    }
  }

  function updateList() {
    Array.prototype.forEach.call(steps.children, (child, index) => {
      child.className = '';
      if (index === currentState) {
        child.classList.add('current');
      } else if (index > currentState) {
        child.classList.add('faded');
      }
    });
  }

  function updateBitmap({ state }) {
    state.flatMap(row => row).forEach((byte, j) => {
      for (let bit = 0; bit < 8; bit++) {
        let cell = document.getElementById(`bit_${j * 8 + bit}`);
        cell.style.backgroundColor = byte & (1 << bit) && 'yellowgreen' || 'black';
      }
    });
  }

  function updatePlot({ state }) {
    state.flat().forEach((byte, j) => {
      let bar = document.getElementById(`bar_${j}`);
      bar.style.height = `${100 * byte / 255}%`;
    });
  }

  function update() {
    cipher(input, expandKey(key));
    cipherText.value = toHex(states[currentState].state.flatMap(x => x));
    updateList();
    updateBitmap(states[currentState]);
    updatePlot(states[currentState]);
  }

  slider.addEventListener('input', e => {
    currentState = parseInt(e.target.value);
    update();
  });

  plaintext.addEventListener('input', e => {
    input = fromHex(e.target.value);
    update();
  });

  keyInput.addEventListener('input', e => {
    key = fromHex(e.target.value);
    update();
  });

  let states = [];
  let input = fromHex(plaintext.value);
  let key = fromHex(keyInput.value);
  let currentState = 0;
  cipherText.value = toHex(input);

  generateSteps();
  generateBitmap();
  generateBars();

  cipher(input, expandKey(key));
  update();
</script>
</html>
